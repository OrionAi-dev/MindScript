import { JsonValue, ISODateTime, JsonObject } from '@mindscript/openspec-types';

/**
 * OpenSpec Events (public, stable, boring)
 * ------------------------------------------------------------
 * This package defines an extremely flexible, vendor-neutral event contract.
 * It intentionally avoids proprietary source enums and domain-specific logic.
 *
 * Private repos implement:
 * - concrete importers
 * - normalization rules
 * - enrichment / entity resolution
 * - domain schemas
 */
/** ---------- Branded IDs ---------- */
type EventId = string & {
    readonly __brand: "EventId";
};
type EntityId = string & {
    readonly __brand: "EntityId";
};
type SourceId = string & {
    readonly __brand: "SourceId";
};
type CorrelationId = string & {
    readonly __brand: "CorrelationId";
};
/**
 * An Entity is "anything that can participate":
 * - person, org, account, device, child, parent, judge, attorney
 * - file, record, case, ticket, medical provider
 * - place, court, clinic, event venue
 * - abstract identity (e.g. "Unknown Caller")
 */
interface EntityRef {
    id: EntityId;
    /** Optional display label (not authoritative) */
    label?: string;
    /**
     * Optional coarse category. Keep it generic.
     * Examples: "person", "organization", "device", "account", "case", "location", "document", "unknown"
     * Consumers can add more detail in ext.
     */
    category?: string;
    /** Optional aliases or handles (avoid raw secrets) */
    aliases?: ReadonlyArray<string>;
    /**
     * Free-form tags for classification:
     * Examples: "minor", "custodian", "provider", "witness", "party", "guardian"
     */
    tags?: ReadonlyArray<string>;
    /** Extension bucket */
    ext?: Record<string, JsonValue>;
}
/**
 * Relationship graph: express any role/relationship imaginable.
 * Examples:
 * - parent_of, represented_by, employed_by, resides_with, custodian_of
 * - sender_to, caller_of, participant_in, owner_of, subject_of
 */
interface RelationshipEdge {
    /** Relationship kind (free-form string). Prefer snake_case. */
    kind: string;
    from: EntityRef;
    to: EntityRef;
    /** Optional qualifiers and role labels (also free-form) */
    roles?: ReadonlyArray<string>;
    /** Optional temporal bounds */
    since?: ISODateTime;
    until?: ISODateTime;
    /** Optional scope: what context/case/project this relationship belongs to */
    scope?: {
        kind?: string;
        id?: string;
    };
    /** Optional confidence + rationale for inferred relationships */
    confidence?: number;
    rationale?: string;
    ext?: Record<string, JsonValue>;
}
/**
 * A Source describes where an event originated, without leaking vendor/app details.
 * It’s not just "file vs api"—it can be a chain (e.g. "device -> export -> parser").
 */
interface SourceDescriptor {
    id: SourceId;
    /**
     * Free-form source type.
     * Examples: "file", "api", "database", "device", "sensor", "manual", "email_gateway", "calendar_provider"
     */
    kind?: string;
    /**
     * Capability tags (free-form).
     * Examples: "authoritative", "user_provided", "third_party", "derived", "redacted", "signed"
     */
    tags?: ReadonlyArray<string>;
    /**
     * Optional human-readable label.
     * Private repos may put product/vendor names here if they want, but public code does not require it.
     */
    label?: string;
    /**
     * Optional opaque account reference (avoid raw identifiers).
     * e.g. hash, internal ID, redacted token
     */
    accountRef?: string;
    /**
     * Optional provenance chain (how it got here).
     * Example: device log -> exported zip -> parsed -> normalized.
     */
    chain?: ReadonlyArray<{
        kind: string;
        at?: ISODateTime;
        by?: EntityRef;
        tool?: string;
        note?: string;
        ext?: Record<string, JsonValue>;
    }>;
    ext?: Record<string, JsonValue>;
}
/**
 * The core event envelope.
 * Event "type" is a namespaced string to avoid schema lock-in.
 * Examples:
 * - "communication.call.started"
 * - "communication.message.sent"
 * - "medical.visit.completed"
 * - "legal.filing.submitted"
 * - "evidence.photo.captured"
 * - "system.import.completed"
 */
interface EventEnvelope<TType extends string = string, TPayload extends JsonObject = JsonObject> {
    id: EventId;
    /** Namespaced event type */
    type: TType;
    /** Canonical time */
    at: ISODateTime;
    /** Optional IANA tz for local interpretation */
    tz?: string;
    /**
     * Participants/entities involved.
     * No role union here — role/meaning lives in `relationships` or payload.
     */
    entities?: ReadonlyArray<EntityRef>;
    /**
     * Optional relationship edges relevant to this event.
     * This is how you model caller/callee, sender/recipient, parent/child, attorney/client, etc.
     */
    relationships?: ReadonlyArray<RelationshipEdge>;
    /** Where the event came from */
    source: SourceDescriptor;
    /** Event-specific payload (consumer-defined) */
    payload: TPayload;
    /**
     * Optional correlation/grouping IDs.
     * Useful for threading: a call session, message thread, case docket entry series, import run, etc.
     */
    correlation?: ReadonlyArray<{
        id: CorrelationId;
        kind?: string;
        label?: string;
        ext?: Record<string, JsonValue>;
    }>;
    /** Optional tags for search/filtering */
    tags?: ReadonlyArray<string>;
    /**
     * Traceability without leaking mechanism.
     * This should point to an opaque record/file handle in the consumer’s system.
     */
    rawRef?: {
        kind: string;
        ref: string;
        checksum?: string;
    };
    /**
     * Confidence & rationale for derived/inferred events.
     * If the event is directly observed, confidence can be omitted.
     */
    confidence?: number;
    rationale?: string;
    /** Extensions */
    ext?: Record<string, JsonValue>;
}
type AnyEvent = EventEnvelope<string, JsonObject>;
/** ---------- Import surfaces ---------- */
interface ImportInput {
    kind: string;
    name?: string;
    bytes?: Uint8Array;
    json?: JsonValue;
    path?: string;
    mimeType?: string;
    ext?: Record<string, JsonValue>;
}
/**
 * Public importer interface: concrete implementations live in private repos.
 * Avoid vendor/product names in id (keep generic).
 */
interface EventImporter {
    id: string;
    supports(input: ImportInput): boolean | Promise<boolean>;
    import(input: ImportInput): AsyncIterable<AnyEvent> | Promise<AsyncIterable<AnyEvent>>;
}
interface EventSink {
    id: string;
    put(events: AsyncIterable<AnyEvent> | Iterable<AnyEvent>): Promise<void>;
}
interface EventStore {
    id: string;
    getById(id: EventId): Promise<AnyEvent | null>;
    query(q: {
        type?: string;
        sourceId?: SourceId;
        entityId?: EntityId;
        since?: ISODateTime;
        until?: ISODateTime;
        limit?: number;
        /** Free-form filter hooks for consumer implementations */
        tagsAny?: ReadonlyArray<string>;
        tagsAll?: ReadonlyArray<string>;
    }): Promise<AnyEvent[]>;
}
/** ---------- Stable helpers (no proprietary logic) ---------- */
declare function makeEventId(s: string): EventId;
declare function makeEntityId(s: string): EntityId;
declare function makeSourceId(s: string): SourceId;
declare function makeCorrelationId(s: string): CorrelationId;

export { type AnyEvent, type CorrelationId, type EntityId, type EntityRef, type EventEnvelope, type EventId, type EventImporter, type EventSink, type EventStore, type ImportInput, type RelationshipEdge, type SourceDescriptor, type SourceId, makeCorrelationId, makeEntityId, makeEventId, makeSourceId };
