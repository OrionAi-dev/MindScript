# Jest Mapper

This adapter connects MindScript `@software` criteria to **Jest** by **referencing existing tests only**. It does **not** generate test code or embed testing semantics into MindScript. Instead, it scans your Jest test suite for lightweight annotations that link tests to MindScript `criteria.id` values and then produces a traceability index.

## Design principles

- **MindScript stays agnostic.** No Jest-specific fields in the MindScript schema.
- **References over generation.** We index links from tests to specs; we do not author tests.
- **Stable IDs.** Links are made with `criteria.id` tokens (e.g., `FEATURE-101.1.1`).

## What it does

- Reads one or more MindScript YAML files that declare:
  - `profile: https://mindscript.dev/profiles/@software`
  - `requirements[].criteria[].id`
- Scans your Jest tests for **MindScript annotations** and builds:
  - `dist/jest/index.json` → map of `criteria.id` → `{ file, describe, it }`
  - `dist/jest/coverage.json` → simple coverage counts per spec (optional)

> By default it looks for tests under `**/__tests__/**/*.test.{js,ts,jsx,tsx}` and `**/*.spec.{js,ts,jsx,tsx}`. You can make this a CLI flag later.

## Annotation conventions (any of these are accepted)

1. **Inline token in test title**
   - `it("creates a session [mindscript:FEATURE-101.1.1]", () => { ... })`
   - `it("login success [OS:FEATURE-101.1.1]", () => { ... })`
2. **Tag comment above the test or describe**
   - `// @mindscript(FEATURE-101.1.1)`
   - `/** @mindscript FEATURE-101.1.1 */`
3. **Describe-level tag to apply to all nested tests**
   - `describe("auth flows @mindscript(FEATURE-101.1)", () => { ... })`

> The mapper extracts **full IDs** (`FEATURE-101.1.1`). If you place a **parent ID** at the `describe` level (`FEATURE-101.1`), nested tests are associated to that parent. You can still add specific child IDs on individual tests.

## Minimal example (MindScript → Jest reference)

MindScript input:

```yaml
profile: https://mindscript.dev/profiles/@software
kind: software
meta:
  id: FEATURE-101
  title: User login
  owner: app-auth
  priority: P0
requirements:
  - id: FEATURE-101.1
    statement: Users can authenticate with valid credentials
    criteria:
      - id: FEATURE-101.1.1
        type: functional
        text: Valid credentials produce a successful session
```

Jest test (referenced, **not** generated by the mapper):

```ts
// auth.login.spec.ts
describe("auth login @mindscript(FEATURE-101.1)", () => {
  it("creates a session [mindscript:FEATURE-101.1.1]", async () => {
    // arrange / act / assert
  });
});
```

Mapper output (traceability index):

```json
{
  "profile": "https://mindscript.dev/profiles/@software",
  "tool": "jest",
  "mappings": [
    {
      "criteria_id": "FEATURE-101.1.1",
      "file": "tests/auth.login.spec.ts",
      "describe": "auth login",
      "it": "creates a session"
    }
  ]
}
```

Optional coverage summary:

```json
{
  "FEATURE-101": {
    "total_criteria": 1,
    "covered": 1,
    "uncovered_ids": []
  }
}
```

## Field mapping (reference-only)

MindScript → Jest

- `criteria[].id` → matched against annotations in test code.
- `requirements[].id` → used for grouping in coverage reports.
- `meta.id`, `meta.title` → used for headings in reports (no code generation).

## File layout

**Inputs**
- MindScript specs: anywhere (examples under `docs/integrations/bdd/@software/examples/`)
- Jest tests: typically `src/**/__tests__/**` or `tests/**`

**Outputs**
- Traceability index → `dist/jest/index.json`
- Optional coverage summary → `dist/jest/coverage.json`

## Validation rules applied

- Each `criteria.id` found in MindScript may be:
  - **Covered**: appears in at least one test annotation
  - **Uncovered**: missing in the test suite (listed in coverage)
- Unknown IDs present in tests (typos) are reported as **dangling**.

## Recommended conventions

- Prefer **single, unambiguous IDs** per test. If a test covers multiple criteria, list multiple tokens:
  - `it("login guards [mindscript:SEC-200.1][mindscript:SEC-200.2]", ...)`
- Keep titles human-readable; use square-bracket tokens or the `@mindscript()` tag for machine parsing.
- If you practice TDD, consider tagging as soon as a test is drafted to avoid drift.

## Integration tips

- CI step order:
  1. Validate MindScript YAML against `@software` schema
  2. Run the Jest mapper to produce `dist/jest/index.json`
  3. Optionally fail the build if there are **uncovered** criteria for `P0/P1` items
- Jest command examples:
  - `npx jest --runInBand`
  - `node tools/jest-mapper scan --spec docs/integrations/bdd/@software/examples --tests tests --out dist/jest`

## Limitations

- The mapper does **not** generate or modify test files.
- It does not execute Jest or collect runtime coverage; it’s **static linking** only.
- It does not resolve IDs across monorepos unless configured with multiple roots/globs.

## Quick checklist

- [ ] MindScript YAML validates and includes `criteria.id` values  
- [ ] Tests include `@mindscript(...)` or `[mindscript:ID]` annotations  
- [ ] `dist/jest/index.json` produced and committed as a build artifact  
- [ ] (Optional) `dist/jest/coverage.json` used to gate CI for critical priorities
